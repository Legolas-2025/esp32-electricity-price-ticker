esphome:
  name: entsoe-hass-compatible
  friendly_name: Entso-E Prices

  # Version 2.2.1 - Fixed AI generated mistakes while upgrading to version 2.2.0 
  # FIX: Lambda Type Conversion
  # Corrected the ternary operator return type for the Price Update Status sensor.
  # FIX: Restored missing sensor publication logic
  # Corrected "Unknown" states for hourly max/min and percentage sensors.
  
  # Version 2.2.0 - CRITICAL FIX: Midnight Update & Robust Retry Logic
  # Fixed: Midnight silent failure caused by trigger timing and retry-count deadlock.
  # Requires ESPHome 2025.12.0+ for API action responses feature.

esp32:
  board: esp32dev
  framework:
    type: arduino

# 1. Wifi & API
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Entsoe-Fallback"
    password: "fallback_pass"

api:
  encryption:
    key: "YOUR_API_ENCRYPTION_KEY_HERE"
  actions:
    - action: verify_price_update
      supports_response: only
      then:
        - api.respond:
            data: !lambda |-
              root["price_updated"] = (id(avg_price).state > 0.0);
              root["current_price"] = id(current_price).state;
              root["avg_price"] = id(avg_price).state;
              root["price_count"] = id(hourly_prices).size();
              root["timestamp"] = id(ha_time).now().timestamp;
              root["update_status"] = id(last_update_success);
              root["retry_count"] = id(retry_count);
              root["status_message"] = id(update_status_message);

ota:
  - platform: esphome

logger:
  level: INFO

# -----------------------------------------------------
# 2. SENSORS
# -----------------------------------------------------
sensor:
  - platform: template
    name: "Current Electricity Price"
    id: current_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:currency-eur"
    lambda: |-
      auto now = id(ha_time).now();
      int local_hour_index = now.hour; 
      int minute_slot = now.minute / 15; 
      int final_index = (local_hour_index * 4) + minute_slot; 
      if (final_index >= 0 && final_index < (int)id(hourly_prices).size()) {
        return id(hourly_prices)[final_index];
      }
      return {}; 
      
  - platform: template
    name: "Next Electricity Price"
    id: next_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-right-circle"
    lambda: |-
      auto now = id(ha_time).now();
      int local_hour_index = now.hour; 
      int minute_slot = now.minute / 15; 
      int next_index = (local_hour_index * 4) + minute_slot + 1; 
      if (next_index >= 0 && next_index < (int)id(hourly_prices).size()) {
        return id(hourly_prices)[next_index];
      }
      return {}; 

  - platform: template
    name: "Average Electricity Price Today"
    id: avg_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:chart-bell-curve"

  - platform: template
    name: "Highest Electricity Price Today"
    id: max_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-up-bold"

  - platform: template
    name: "Lowest Electricity Price Today"
    id: min_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-down-bold"

  - platform: template
    name: "Current Hourly Electricity Price"
    id: current_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:chart-line"
    lambda: |-
      auto now = id(ha_time).now();
      int hourly_index = now.hour;
      if (hourly_index >= 0 && hourly_index < (int)id(hourly_avg_prices_kwh).size()) {
        return id(hourly_avg_prices_kwh)[hourly_index];
      }
      return {}; 

  - platform: template
    name: "Next Hourly Electricity Price"
    id: next_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-right-circle-outline"
    lambda: |-
      auto now = id(ha_time).now();
      int next_hourly_index = now.hour + 1;
      if (next_hourly_index >= 0 && next_hourly_index < (int)id(hourly_avg_prices_kwh).size()) {
        return id(hourly_avg_prices_kwh)[next_hourly_index];
      }
      return {};

  - platform: template
    name: "Highest Hourly Electricity Price Today"
    id: max_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-up-bold-box"

  - platform: template
    name: "Lowest Hourly Electricity Price Today"
    id: min_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-down-bold-box"

  - platform: template
    name: "Current Max Hourly Price Percentage"
    id: current_max_hourly_price_percentage
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:percent"
    lambda: |-
      float current_p = id(current_hourly_price).state;
      float max_p = id(max_hourly_price).state;
      if (std::isnan(current_p) || std::isnan(max_p) || max_p <= 0.0) return {}; 
      return (current_p / max_p) * 100.0;

  - platform: template
    name: "Price Update Retry Count"
    id: price_retry_count
    icon: "mdi:counter"
    lambda: |-
      return id(retry_count);

# -----------------------------------------------------
# 3. TEXT SENSORS
# -----------------------------------------------------
text_sensor:
  - platform: template
    name: "ENTSO-E Hourly Prices EUR/kWh JSON"
    id: json_hourly_prices_kwh
    icon: "mdi:code-json"
    
  - platform: template
    name: "Time Of Highest Energy Price Today"
    id: max_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: 'return id(max_price_time_str);'

  - platform: template
    name: "Time Of Lowest Energy Price Today"
    id: min_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: 'return id(min_price_time_str);'
    
  - platform: template
    name: "Time Of Highest Hourly Energy Price Today"
    id: max_hourly_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: 'return id(max_hourly_price_time_str);'

  - platform: template
    name: "Time Of Lowest Hourly Energy Price Today"
    id: min_hourly_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: 'return id(min_hourly_price_time_str);'

  - platform: template
    name: "Price Update Status"
    id: price_update_status
    icon: "mdi:update"
    lambda: |-
      return id(last_update_success) ? std::string("SUCCESS") : std::string("FAILED/WAITING");

  - platform: template
    name: "Last Price Update Time"
    id: last_price_update_time
    icon: "mdi:clock-outline"
    lambda: |-
      time_t last_update = id(last_update_attempt);
      if (last_update > 0) {
        struct tm *tm_info = localtime(&last_update);
        char time_buf[20];
        strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", tm_info);
        return std::string(time_buf);
      }
      return std::string("Never");

  - platform: template
    name: "Price Update Status Message"
    id: price_status_message
    icon: "mdi:message-text-outline"
    lambda: 'return id(update_status_message);'

# -----------------------------------------------------
# 4. TIME & SCHEDULING
# -----------------------------------------------------
time:
  - platform: homeassistant
    id: ha_time 
    timezone: "YOUR_TIMEZONE_HERE"
    # For instance: Europe/Ljubljana
    on_time:
      - minutes: /15
        seconds: 2
        then:
          - component.update: current_price
          - component.update: next_price
          - component.update: current_hourly_price
          - component.update: next_hourly_price
          - component.update: current_max_hourly_price_percentage

      - hours: 0
        minutes: 0
        seconds: 30
        then:
          - lambda: |-
              ESP_LOGI("entsoe", "Midnight Reset");
              id(last_update_success) = false;
              id(retry_count) = 0;
          - script.execute: smart_price_update

      - minutes: /5
        seconds: 10
        then:
          - if:
              condition:
                lambda: 'return (!id(last_update_success));'
              then:
                - script.execute: smart_price_update

      - seconds: 45
        then:
          - if:
              condition:
                lambda: 'return !id(boot_recovery_executed);'
              then:
                - script.execute: smart_price_update
                - lambda: 'id(boot_recovery_executed) = true;'

# -----------------------------------------------------
# 5. GLOBALS & HTTP
# -----------------------------------------------------
http_request:
  verify_ssl: false

globals:
  - id: hourly_prices
    type: std::vector<float>
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'
  - id: hourly_prices_mwh
    type: std::vector<float>
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'
  - id: hourly_avg_prices_kwh
    type: std::vector<float>
    initial_value: '{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}'
  - id: min_price_time_str
    type: std::string
    initial_value: '"00:00"'
  - id: max_price_time_str
    type: std::string
    initial_value: '"00:00"'
  - id: min_hourly_price_time_str
    type: std::string
    initial_value: '"00:00"'
  - id: max_hourly_price_time_str
    type: std::string
    initial_value: '"00:00"'
  - id: last_successful_update
    type: time_t
    initial_value: '0'
  - id: last_update_attempt
    type: time_t
    initial_value: '0'
  - id: last_update_success
    type: bool
    initial_value: 'false'
  - id: update_status_message
    type: std::string
    initial_value: '"System Boot"'
  - id: retry_count
    type: int
    initial_value: '0'
  - id: boot_recovery_executed
    type: bool
    initial_value: 'false'
  - id: api_token
    type: std::string
    initial_value: '"YOUR_ENTSOE_API_TOKEN_HERE"'
  - id: area_code
    type: std::string
    initial_value: '"YOUR_COUNTRY_AREA_CODE_HERE"' 
    # For instance: 10YSI-ELES-----O

button:
  - platform: template
    name: "Entso-E Force Update"
    id: entsoe_force_update
    on_press:
      - lambda: 'id(retry_count) = 0;'
      - script.execute: smart_price_update

# -----------------------------------------------------
# 6. SCRIPTS
# -----------------------------------------------------
script:
  - id: smart_price_update
    then:
      - lambda: |-
          id(last_update_attempt) = id(ha_time).now().timestamp;
          id(retry_count)++;
      - script.execute: full_update_logic_script
      - lambda: |-
          if (id(avg_price).state > 0.0) {
            id(last_successful_update) = id(ha_time).now().timestamp;
            id(last_update_success) = true;
            id(update_status_message) = "Update Successful";
          } else {
            id(last_update_success) = false;
            char msg[60];
            sprintf(msg, "Failed (Attempt %d)", id(retry_count));
            id(update_status_message) = std::string(msg);
          }
          id(price_update_status).update();
          id(price_status_message).update();
          id(last_price_update_time).update();
          id(price_retry_count).update();
          // Update derived sensors immediately
          id(current_price).update();
          id(current_hourly_price).update();
          id(current_max_hourly_price_percentage).update();

  - id: full_update_logic_script
    then:
      - lambda: |-
          const float PROVIDER_FEE = 0.12; 
          const float VAT_RATE = 0.22; 
          const float MULTIPLIER = (1.0 + PROVIDER_FEE) * (1.0 + VAT_RATE);

          auto time_now = id(ha_time).now();
          time_t now_ts = time_now.timestamp;
          time_t yesterday_ts = now_ts - 86400;
          struct tm *tm_y = localtime(&yesterday_ts);
          
          char buf[16];
          sprintf(buf, "%04d%02d%02d2300", tm_y->tm_year + 1900, tm_y->tm_mon + 1, tm_y->tm_mday);
          std::string pStart = std::string(buf);
          sprintf(buf, "%04d%02d%02d2300", time_now.year, time_now.month, time_now.day_of_month);
          std::string pEnd = std::string(buf);

          std::string url = "https://web-api.tp.entsoe.eu/api?securityToken=" + id(api_token) + 
                            "&documentType=A44&in_Domain=" + id(area_code) + 
                            "&out_Domain=" + id(area_code) + 
                            "&periodStart=" + pStart + "&periodEnd=" + pEnd;

          HTTPClient http;
          http.begin(url.c_str());
          int httpCode = http.GET();
          
          if (httpCode == 200) {
            String payload = http.getString();
            std::string xml = payload.c_str();
            std::vector<float> n_kwh(96, 0.0);
            std::vector<float> n_mwh(96, 0.0);
            std::vector<float> h_sums(24, 0.0);
            std::vector<int> h_counts(24, 0);
            int count = 0;
            float min_p = 9999, max_p = -9999, sum_p = 0;
            std::string min_t = "00:00", max_t = "00:00";

            size_t pos = 0;
            while ((pos = xml.find("<Point>", pos)) != std::string::npos) {
              size_t end = xml.find("</Point>", pos);
              if (end == std::string::npos) break;
              std::string p_xml = xml.substr(pos, end - pos);
              
              size_t s_pos = p_xml.find("<position>");
              size_t e_pos = p_xml.find("</position>");
              size_t s_pri = p_xml.find("<price.amount>");
              size_t e_pri = p_xml.find("</price.amount>");

              if (s_pos != std::string::npos && s_pri != std::string::npos) {
                int idx = parse_number<int>(p_xml.substr(s_pos+10, e_pos-(s_pos+10))).value_or(0) - 1;
                float raw = parse_number<float>(p_xml.substr(s_pri+14, e_pri-(s_pri+14))).value_or(0.0);
                
                if (idx >= 0 && idx < 96) {
                  float f_mwh = raw * MULTIPLIER;
                  float f_kwh = f_mwh / 1000.0;
                  n_kwh[idx] = f_kwh;
                  n_mwh[idx] = f_mwh;
                  sum_p += f_kwh;
                  count++;

                  int hr = idx / 4;
                  char t_buf[6]; sprintf(t_buf, "%02d:%02d", hr, (idx % 4) * 15);
                  if (f_kwh < min_p) { min_p = f_kwh; min_t = t_buf; }
                  if (f_kwh > max_p) { max_p = f_kwh; max_t = t_buf; }
                  h_sums[hr] += f_kwh; h_counts[hr]++;
                }
              }
              pos = end + 8;
            }

            if (count >= 90) {
              id(hourly_prices) = n_kwh;
              id(hourly_prices_mwh) = n_mwh;
              id(min_price).publish_state(min_p);
              id(max_price).publish_state(max_p);
              id(avg_price).publish_state(sum_p / count);
              id(min_price_time_str) = min_t;
              id(max_price_time_str) = max_t;

              // RESTORED HOURLY SENSOR LOGIC
              float h_min_val = 9999, h_max_val = -9999;
              int h_min_idx = 0, h_max_idx = 0;
              std::string json = "[";
              
              for (int i=0; i<24; i++) {
                float avg = h_counts[i] > 0 ? h_sums[i]/h_counts[i] : 0;
                id(hourly_avg_prices_kwh)[i] = avg;
                
                if (avg < h_min_val) { h_min_val = avg; h_min_idx = i; }
                if (avg > h_max_val) { h_max_val = avg; h_max_idx = i; }
                
                char p_buf[10]; sprintf(p_buf, "%.4f", avg);
                json += p_buf; if(i<23) json += ",";
              }
              json += "]";
              
              id(json_hourly_prices_kwh).publish_state(json.c_str());
              id(max_hourly_price).publish_state(h_max_val);
              id(min_hourly_price).publish_state(h_min_val);
              
              char h_buf[6];
              sprintf(h_buf, "%02d:00", h_max_idx); id(max_hourly_price_time_str) = h_buf;
              sprintf(h_buf, "%02d:00", h_min_idx); id(min_hourly_price_time_str) = h_buf;
              
              id(max_hourly_price_time).publish_state(id(max_hourly_price_time_str));
              id(min_hourly_price_time).publish_state(id(min_hourly_price_time_str));
            }
          }
          http.end();
