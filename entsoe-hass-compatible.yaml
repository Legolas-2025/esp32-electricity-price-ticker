esphome:
  name: entsoe-hass-compatible
  friendly_name: Entso-E Prices
  
  # Version 2.0.0 - Enhanced with Smart Retry Logic, Status Monitoring & Boot-up Updates
  # Requires ESPHome 2025.12.0+ for API action responses feature

esp32:
  board: esp32dev
  framework:
    type: arduino # Required for HTTPClient

# 1. Wifi & API
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Entsoe-Fallback"
    password: "fallback_pass"

api:
  encryption:
    key: "YOUR_API_ENCRYPTION_KEY_HERE"
  # Enable actions for bidirectional communication with Home Assistant
  actions:
    - action: verify_price_update
      supports_response: only
      then:
        - api.respond:
            data: !lambda |-
              root["price_updated"] = (id(avg_price).state > 0.0);
              root["current_price"] = id(current_price).state;
              root["avg_price"] = id(avg_price).state;
              root["price_count"] = id(hourly_prices).size();
              root["timestamp"] = id(ha_time).now().timestamp;
              root["update_status"] = id(last_update_success);
              root["retry_count"] = id(retry_count);
              root["status_message"] = id(update_status_message);

ota:
  - platform: esphome

logger:
  level: INFO

# -----------------------------------------------------
# 2. SENSORS (Template Sensors)
# -----------------------------------------------------
sensor:
  # --- 15-MINUTE PRICE SENSORS ---
  - platform: template
    name: "Current Electricity Price"
    id: current_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:currency-eur"
    lambda: |-
      auto now = id(ha_time).now();
      int local_hour_index = now.hour; 
      int minute_slot = now.minute / 15; 
      
      // OFFSET 0 is correct now that we fetch the correct day
      const int HOUR_OFFSET = 0; 
      
      int final_index = ((local_hour_index + HOUR_OFFSET) * 4) + minute_slot; 
      
      if (final_index >= 0 && final_index < id(hourly_prices).size()) {
        return id(hourly_prices)[final_index];
      }
      return {}; 
      
  - platform: template
    name: "Next Electricity Price"
    id: next_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-right-circle"
    lambda: |-
      auto now = id(ha_time).now();
      int local_hour_index = now.hour; 
      int minute_slot = now.minute / 15; 
      const int HOUR_OFFSET = 0; 
      
      int next_index = ((local_hour_index + HOUR_OFFSET) * 4) + minute_slot + 1; 
      
      if (next_index >= 0 && next_index < id(hourly_prices).size()) {
        return id(hourly_prices)[next_index];
      }
      return {}; 

  - platform: template
    name: "Average Electricity Price Today"
    id: avg_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:chart-bell-curve"

  - platform: template
    name: "Highest Electricity Price Today"
    id: max_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-up-bold"

  - platform: template
    name: "Lowest Electricity Price Today"
    id: min_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-down-bold"

  # --- HOURLY PRICE SENSORS ---
  - platform: template
    name: "Current Hourly Electricity Price"
    id: current_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:chart-line"
    lambda: |-
      auto now = id(ha_time).now();
      int hourly_index = now.hour;
      
      if (hourly_index >= 0 && hourly_index < id(hourly_avg_prices_kwh).size()) {
        return id(hourly_avg_prices_kwh)[hourly_index];
      }
      return {}; 

  - platform: template
    name: "Next Hourly Electricity Price"
    id: next_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-right-circle-outline"
    lambda: |-
      auto now = id(ha_time).now();
      int hourly_index = now.hour;
      int next_hourly_index = hourly_index + 1;
      
      if (next_hourly_index >= 0 && next_hourly_index < id(hourly_avg_prices_kwh).size()) {
        return id(hourly_avg_prices_kwh)[next_hourly_index];
      }
      return {};

  - platform: template
    name: "Highest Hourly Electricity Price Today"
    id: max_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-up-bold-box"

  - platform: template
    name: "Lowest Hourly Electricity Price Today"
    id: min_hourly_price
    unit_of_measurement: "€/kWh"
    accuracy_decimals: 4
    icon: "mdi:arrow-down-bold-box"

  # --- HOURLY PERCENTAGE SENSOR ---
  - platform: template
    name: "Current Max Hourly Price Percentage"
    id: current_max_hourly_price_percentage
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:percent"
    lambda: |-
      float current_price = id(current_hourly_price).state;
      float max_price = id(max_hourly_price).state;
      
      if (std::isnan(current_price) || std::isnan(max_price) || max_price <= 0.0) {
        return {}; 
      }
      return (current_price / max_price) * 100.0;

  # --- STATUS MONITORING SENSORS (numeric) ---
  - platform: template
    name: "Price Update Retry Count"
    id: price_retry_count
    icon: "mdi:counter"
    lambda: |-
      return id(retry_count);

# -----------------------------------------------------
# 3. TEXT SENSORS
# -----------------------------------------------------
text_sensor:
  # --- HOURLY JSON PRICE VECTOR (24 prices) ---
  - platform: template
    name: "ENTSO-E Hourly Prices EUR/kWh JSON"
    id: json_hourly_prices_kwh
    icon: "mdi:code-json"
    
  # --- TIME SENSORS ---
  - platform: template
    name: "Time Of Highest Energy Price Today"
    id: max_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: |-
      return id(max_price_time_str);

  - platform: template
    name: "Time Of Lowest Energy Price Today"
    id: min_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: |-
      return id(min_price_time_str);
    
  - platform: template
    name: "Time Of Highest Hourly Energy Price Today"
    id: max_hourly_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: |-
      return id(max_hourly_price_time_str);

  - platform: template
    name: "Time Of Lowest Hourly Energy Price Today"
    id: min_hourly_price_time
    entity_category: "diagnostic"
    icon: "mdi:clock-time-three"
    lambda: |-
      return id(min_hourly_price_time_str);

  # --- NEW: STATUS MONITORING TEXT SENSORS (Version 2.0.0) ---
  - platform: template
    name: "Price Update Status"
    id: price_update_status
    icon: "mdi:update"
    lambda: |-
      if (id(last_update_success)) {
        return std::string("SUCCESS");
      } else {
        return std::string("FAILED");
      }

  - platform: template
    name: "Last Price Update Time"
    id: last_price_update_time
    icon: "mdi:clock-outline"
    lambda: |-
      time_t last_update = id(last_update_attempt);
      if (last_update > 0) {
        struct tm *tm_info = localtime(&last_update);
        char time_buf[20];
        strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", tm_info);
        return std::string(time_buf);
      }
      return std::string("Never");

  - platform: template
    name: "Price Update Status Message"
    id: price_status_message
    icon: "mdi:message-text-outline"
    lambda: |-
      return id(update_status_message);

# 4. Time Component & Scheduling
time:
  - platform: homeassistant
    id: ha_time 
    timezone: "YOUR_TIMEZONE_HERE"
    on_time:
      # Run sensor updates every 15 minutes
      - minutes: /15
        seconds: 1
        then:

          - lambda: id(current_price).update();
          - lambda: id(next_price).update(); 
          - lambda: id(current_hourly_price).update(); 
          - lambda: id(next_hourly_price).update(); 
          - lambda: id(current_max_hourly_price_percentage).update();
          # Enhanced: Smart price update with retry logic (Version 2.0.0)
          - if:
              condition:
                # Execute IF the current time is 00:00:01 (primary fetch)
                lambda: 'return (id(ha_time).now().hour == 0 && id(ha_time).now().minute == 0);'
              then:
                - script.execute: smart_price_update
      # NEW: Boot recovery - trigger once shortly after boot
      - seconds: 35  # 35 seconds after boot (first minute)
        then:
          - if:
              condition:
                lambda: 'return id(boot_recovery_executed) == false;'
              then:
                - script.execute: smart_price_update
                - lambda: 'id(boot_recovery_executed) = true;'

# 5. HTTP Request
http_request:
  verify_ssl: false

# -----------------------------------------------------
# 6. GLOBALS (VECTORS & TRACKING STRINGS)
# -----------------------------------------------------
globals:
  # 15-MINUTE PRICE VECTORS (96 elements)
  - id: hourly_prices
    type: std::vector<float>
    initial_value: '{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}'
  - id: hourly_prices_mwh
    type: std::vector<float>
    initial_value: '{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}'
  
  # HOURLY PRICE VECTOR (24 elements)
  - id: hourly_avg_prices_kwh
    type: std::vector<float>
    initial_value: '{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}'
  
  # PRICE TIME TRACKERS (15-min)
  - id: min_price_time_str
    type: std::string
    initial_value: '"00:00"'
  - id: max_price_time_str
    type: std::string
    initial_value: '"00:00"'

  # PRICE TIME TRACKERS (Hourly)
  - id: min_hourly_price_time_str
    type: std::string
    initial_value: '"00:00"'
  - id: max_hourly_price_time_str
    type: std::string
    initial_value: '"00:00"'

  # NEW: Smart retry and status tracking globals (Version 2.0.0)
  - id: last_successful_update
    type: time_t
    initial_value: '0'
  - id: last_update_attempt
    type: time_t
    initial_value: '0'
  - id: last_update_success
    type: bool
    initial_value: 'false'
  - id: update_status_message
    type: std::string
    initial_value: '"Boot-up price update"'
  - id: retry_count
    type: int
    initial_value: '0'
  - id: max_retries
    type: int
    initial_value: '3'
  # NEW: Boot recovery tracking (Version 2.0.0)
  - id: boot_recovery_executed
    type: bool
    initial_value: 'false'

  # API DETAILS
  - id: api_token
    type: std::string
    # !!! PASTE YOUR TOKEN BELOW !!!
    initial_value: '"YOUR_ENTSOE_API_TOKEN_HERE"' 
  - id: area_code
    type: std::string
    # Slovenia (ELES) Area Code
    initial_value: '"YOUR_COUNTRY_AREA_CODE_HERE"' 

# Button triggers the smart update script
button:
  - platform: template
    name: "Entso-E Force Update"
    id: entsoe_force_update
    icon: "mdi:refresh-circle"
    on_press:
      - script.execute: smart_price_update

# -----------------------------------------------------
# 7. SMART PRICE UPDATE SCRIPTS (Version 2.0.0)
# -----------------------------------------------------
script:
  # Smart price update script with retry logic
  - id: smart_price_update
    then:
      # Step 1: Update status - attempt started
      - lambda: |-
          id(last_update_attempt) = id(ha_time).now().timestamp;
          id(update_status_message) = "Midnight smart update started";

      # Step 2: Check if we need to retry or if data is already fresh
      - lambda: |-
          auto now = id(ha_time).now().timestamp;
          if (now - id(last_successful_update) < 3600) { // Less than 1 hour old
            ESP_LOGI("entsoe", "Price data is fresh, skipping update");
            id(update_status_message) = "Data fresh - midnight update skipped";
            id(last_update_success) = true;
            
            // Update status sensors
            id(price_update_status).update();
            id(price_status_message).update();
            id(last_price_update_time).update();
            return;
          }

      # Step 3: Check retry limit
      - lambda: |-
          if (id(retry_count) >= id(max_retries)) {
            ESP_LOGW("entsoe", "Max retries reached, giving up");
            id(update_status_message) = "FAILED: Max retries exceeded (3/3)";
            id(last_update_success) = false;
            
            // Update all status sensors
            id(price_update_status).update();
            id(price_status_message).update();
            id(last_price_update_time).update();
            id(price_retry_count).update();
            
            id(retry_count) = 0; // Reset for next cycle
            return;
          }

      # Step 4: Execute the full update logic
      - script.execute: full_update_logic_script
      - delay: 60s
      
      # Step 5: Verify update success (simplified - no HA action)
      - lambda: |-
          float current_avg = id(avg_price).state;
          
          if (current_avg > 0.0) {
            // SUCCESS: Data update verified
            ESP_LOGI("entsoe", "Price update verified - average: %.4f €/kWh", current_avg);
            id(last_successful_update) = id(ha_time).now().timestamp;
            id(retry_count) = 0;
            id(last_update_success) = true;
            id(update_status_message) = "SUCCESS: Price data updated";
            
            ESP_LOGI("entsoe", "Price update SUCCESS - %d prices processed", 96);
          } else {
            // FAILURE: No valid data
            ESP_LOGW("entsoe", "Price update failed - no valid data");
            id(retry_count) += 1;
            id(last_update_success) = false;
            
            char msg[50];
            sprintf(msg, "FAILED: No valid data (%d/3)", id(retry_count));
            id(update_status_message) = std::string(msg);
            
            ESP_LOGW("entsoe", "Price update FAILED, attempt %d/%d", id(retry_count), id(max_retries));
            
            // If this was the final attempt, prepare for next day
            if (id(retry_count) >= id(max_retries)) {
              ESP_LOGE("entsoe", "ALL UPDATE ATTEMPTS FAILED - ALERT REQUIRED");
              id(update_status_message) = "CRITICAL: All 3 attempts failed";
            }
          }
          
          // Update status sensors
          id(price_update_status).update();
          id(price_retry_count).update();
          id(price_status_message).update();
          id(last_price_update_time).update();

  # Enhanced: Original full update logic with status updates
  - id: full_update_logic_script
    then:
      - lambda: |-
          // *****************************************************************
          // !!! Configuration Section for Taxes and Fees !!!
          // -----------------------------------------------------------------
          // The electricity price is calculated as:
          // Raw_Price * (1 + Provider_Fee_Percentage) * (1 + VAT_Percentage)
          
          // 1. Provider Fee Percentage (e.g., 0.12 = 12% fee)
          // Adjust this value according to your electricity provider's fee/markup.
          const float PROVIDER_FEE = 0.12; 
          
          // 2. VAT Percentage (e.g., 0.22 = 22% VAT)
          // Adjust this value according to the current governmental VAT rate.
          const float VAT_RATE = 0.22; 
          
          // Calculated Multiplier
          const float TOTAL_PRICE_MULTIPLIER = (1.0 + PROVIDER_FEE) * (1.0 + VAT_RATE);
          // *****************************************************************

          // 1. Get Correct Dates for TODAY'S Market Day (Starts Yesterday 23:00)
          auto time_now = id(ha_time).now();
          time_t now_ts = time_now.timestamp;
          
          // Calculate PeriodStart: Current Timestamp - 24 Hours (86400s)
          time_t yesterday_ts = now_ts - 86400;
          struct tm *tm_yesterday = localtime(&yesterday_ts);
          
          char date_buf[16];
          sprintf(date_buf, "%04d%02d%02d2300", tm_yesterday->tm_year + 1900, tm_yesterday->tm_mon + 1, tm_yesterday->tm_mday);
          std::string periodStart = std::string(date_buf);
          
          sprintf(date_buf, "%04d%02d%02d2300", time_now.year, time_now.month, time_now.day_of_month);
          std::string periodEnd = std::string(date_buf);
          
          ESP_LOGD("entsoe", "Fetching Market Day. Requesting: %s to %s", periodStart.c_str(), periodEnd.c_str());

          // 2. Build URL
          std::string url = "https://web-api.tp.entsoe.eu/api?securityToken=" + id(api_token) + 
                            "&documentType=A44&in_Domain=" + id(area_code) + 
                            "&out_Domain=" + id(area_code) + 
                            "&periodStart=" + periodStart + 
                            "&periodEnd=" + periodEnd;
                            
          ESP_LOGD("entsoe", "Fetching URL: %s", url.c_str());

          // 3. Execute Request
          HTTPClient http;
          http.begin(url.c_str());
          http.setReuse(false);
          
          int httpCode = http.GET();
          
          if (httpCode > 0) {
            String payload = http.getString();
            std::string xml = payload.c_str();
            
            // 4. Parse & Calculate
            std::vector<float> new_prices_kwh(96, 0.0);
            std::vector<float> new_prices_mwh(96, 0.0);
            int found_prices_count = 0; 
            
            // 15-Minute Trackers
            float min_p = 9999.0; 
            float max_p = -9999.0;
            float sum_p = 0.0;
            std::string min_time = "00:00";
            std::string max_time = "00:00";

            // Hourly Trackers
            std::vector<float> hourly_sums(24, 0.0);
            std::vector<int> hourly_counts(24, 0); 
            
            float min_hourly_p = 9999.0;
            float max_hourly_p = -9999.0;
            std::string min_hourly_time = "00:00";
            std::string max_hourly_time = "00:00";

            std::string point_start_tag = "<Point>";
            std::string point_end_tag = "</Point>";
            std::string position_tag = "<position>";
            std::string price_tag = "<price.amount>";
            
            ESP_LOGI("entsoe", "Using Hardcoded Fees: %.2f (%.0f%%), VAT: %.2f (%.0f%%) -> Multiplier: %.4f", PROVIDER_FEE, PROVIDER_FEE*100, VAT_RATE, VAT_RATE*100, TOTAL_PRICE_MULTIPLIER);

            size_t pos = 0;
            
            while ((pos = xml.find(point_start_tag, pos)) != std::string::npos) {
              size_t point_end = xml.find(point_end_tag, pos);
              if (point_end == std::string::npos) break;

              std::string point_xml = xml.substr(pos, point_end - pos);
              
              // --- A. Extract Position (1-96) ---
              size_t pos_start = point_xml.find(position_tag);
              size_t pos_end = point_xml.find("</position>");
              if (pos_start == std::string::npos || pos_end == std::string::npos) {
                  pos = point_end + point_end_tag.length();
                  continue;
              }
              std::string pos_str = point_xml.substr(pos_start + position_tag.length(), pos_end - (pos_start + position_tag.length()));
              int position = parse_number<int>(pos_str).value_or(0);
              int price_index = position - 1; // Array Index (0-95)
              
              if (price_index >= 0 && price_index < 96) {
                  
                  // --- B. Extract Price (EUR/MWh) ---
                  size_t price_start = point_xml.find(price_tag);
                  size_t price_end = point_xml.find("</price.amount>");
                  
                  if (price_start != std::string::npos && price_end != std::string::npos) {
                      std::string val_str = point_xml.substr(price_start + price_tag.length(), price_end - (price_start + price_tag.length()));
                      float raw_price_per_MWh = parse_number<float>(val_str).value_or(0.0);
                      
                      // --- C. Price Conversion and Taxes ---
                      float final_price_per_MWh = raw_price_per_MWh * TOTAL_PRICE_MULTIPLIER;
                      float final_price_per_kWh = final_price_per_MWh / 1000.0; 

                      new_prices_kwh[price_index] = final_price_per_kWh;
                      new_prices_mwh[price_index] = final_price_per_MWh;
                      sum_p += final_price_per_kWh;
                      found_prices_count++; 
                      
                      // --- D. Calculate Local Time (Based on Position/Index) ---
                      int hour_of_day = price_index / 4;
                      int minute_of_hour = (price_index % 4) * 15;
                      
                      char time_buf[6];
                      sprintf(time_buf, "%02d:%02d", hour_of_day, minute_of_hour);
                      std::string time_hhmm = std::string(time_buf);
                      
                      // E. Min/Max Tracking
                      if(final_price_per_kWh < min_p) {
                          min_p = final_price_per_kWh;
                          min_time = time_hhmm;
                      }
                      if(final_price_per_kWh > max_p) {
                          max_p = final_price_per_kWh;
                          max_time = time_hhmm;
                      }

                      // F. Hourly Summation
                      if (hour_of_day < 24) { 
                          hourly_sums[hour_of_day] += final_price_per_kWh;
                          hourly_counts[hour_of_day]++;
                      }
                  } 
              }

              pos = point_end + point_end_tag.length();
            } 

            // 5. Calculate Hourly Averages
            std::vector<float> new_hourly_avg_prices_kwh;
            
            for (int i = 0; i < 24; i++) {
                float avg_price = 0.0;
                
                if (hourly_counts[i] > 0) {
                    avg_price = hourly_sums[i] / hourly_counts[i];
                }

                new_hourly_avg_prices_kwh.push_back(avg_price);
                    
                // Hourly Min/Max Tracking
                if (hourly_counts[i] > 0) {
                    if (avg_price < min_hourly_p) {
                        min_hourly_p = avg_price;
                        char h_buf[6];
                        sprintf(h_buf, "%02d:00", i); 
                        min_hourly_time = std::string(h_buf);
                    }
                    if (avg_price > max_hourly_p) {
                        max_hourly_p = avg_price;
                        char h_buf[6];
                        sprintf(h_buf, "%02d:00", i);
                        max_hourly_time = std::string(h_buf);
                    }
                }
            }

            // 6. Final Update Check and Global Assignment
            if (found_prices_count >= 90) { 
              // 15-Minute Updates 
              id(hourly_prices) = new_prices_kwh;
              id(hourly_prices_mwh) = new_prices_mwh;
              
              id(min_price).publish_state(min_p);
              id(max_price).publish_state(max_p);
              id(avg_price).publish_state(sum_p / found_prices_count);
              
              id(min_price_time_str) = min_time;
              id(max_price_time_str) = max_time;

              // Hourly Updates 
              id(hourly_avg_prices_kwh) = new_hourly_avg_prices_kwh;
              
              id(min_hourly_price).publish_state(min_hourly_p);
              id(max_hourly_price).publish_state(max_hourly_p);
              
              id(min_hourly_price_time_str) = min_hourly_time;
              id(max_hourly_price_time_str) = max_hourly_time;
              
              // Hourly JSON String Generation
              std::string json_hourly_prices = "[";
              
              for(size_t i=0; i<new_hourly_avg_prices_kwh.size(); i++) {
                char p_buf[8];
                sprintf(p_buf, "%.4f", new_hourly_avg_prices_kwh[i]); 
                std::string val_str = std::string(p_buf);

                json_hourly_prices += val_str;
                if(i < new_hourly_avg_prices_kwh.size() - 1) json_hourly_prices += ",";
              }
              json_hourly_prices += "]";
              
              ESP_LOGI("entsoe", "Publishing Hourly JSON (24 points), Length: %d", json_hourly_prices.length());
              id(json_hourly_prices_kwh).publish_state(json_hourly_prices.c_str());
              
              
              ESP_LOGI("entsoe", "Successfully updated all prices and statistics. Found %d prices.", found_prices_count);
              
              // Trigger template sensor updates
              id(max_price_time).update();
              id(min_price_time).update();
              id(current_hourly_price).update();
              id(current_max_hourly_price_percentage).update();
              
            } else {
              ESP_LOGW("entsoe", "Failed to parse prices. Found only %d points. Data considered invalid.", found_prices_count);
            }
          } else {
            ESP_LOGW("entsoe", "HTTP Request failed. Code: %d", httpCode);
          }
          http.end();
